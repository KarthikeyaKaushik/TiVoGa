pub = rospy.Publisher('/turning_angle', String, queue_size=10)
angle = ""

def choose_data():
    global record_mode
    while not rospy.is_shutdown():
        user_input = raw_input(
            """Control of data collection:
    0:= Pause recording
    1:= Start recording
    2:= Stop recording -- not implemented yet
    3:= Continue recording -- not implemented yet

    the new data is saved only if there is a change of position more than 10cm

Type 'exit' to quit.\n""")
        try:
            record_mode = int(user_input)
            if record_mode < 0 or record_mode > 1:
                record_mode = 0
            else:
                print "You entered:" + user_input
            return
        except ValueError:
            if user_input == 'exit':
                return
            print "Invalid Input"


def callback_calc_vector(msg):
    global snake_head_pos
    global snake_tail_pos
    global target_pos
    global time_passed
    global record_stopped
    global target_captured
    global dir_vector
    global mov_vector
    snake_tmp_pos = [0.0, 0.0]
    rotated_vector = [0.0, 0.0]

    if record_mode == 0:
        # just resetting the parameters
        target_captured = 0
        time_passed = 0
        target_pos = [0.0, 0.0]
        snake_head_pos = [0.0, 0.0]

    if record_mode == 1:
        # we start our calculations by probing the target coordinates
        #if we already have a target then we dont have to get this info again
        if target_captured == 0:
            target_pos = [msg.pose[2].position.x, msg.pose[2].position.y]
            target_captured = 1

        # counting our time
        time_passed += 1

        # getting the current snake head coordinates and comparing them to stored ones
        #snake_tmp_pos[0] = msg.pose[1].position.x
        #snake_tmp_pos[1] = msg.pose[1].position.y
        #if abs(snake_tmp_pos[0] - snake_head_pos[0]) > 0.2 or abs(snake_tmp_pos[1] - snake_head_pos[1]) > 0.2:

        #short list of number meanings:
        # 800 = 1 sec
        # 400 = 0.5 sec
        # 160 = 200 msec
        # 40 = 50 msec
        if time_passed == 40:
            time_passed = 0
            snake_head_pos = [msg.pose[1].position.x, msg.pose[1].position.y]
            # calculating the head-target vector and general movement vector in "ground_plane" coordinates' system
            dir_vector[0] = (snake_head_pos[0] - target_pos[0]) / math.sqrt(
                pow(snake_head_pos[0] - target_pos[0], 2) + pow(snake_head_pos[1] - target_pos[1], 2))
            dir_vector[1] = (snake_head_pos[1] - target_pos[1]) / math.sqrt(
                pow(snake_head_pos[0] - target_pos[0], 2) + pow(snake_head_pos[1] - target_pos[1], 2))
            mov_vector[0] = (snake_head_pos[0] - snake_tail_pos[0]) / math.sqrt(
                pow(snake_head_pos[0] - snake_tail_pos[0], 2) + pow(snake_head_pos[1] - snake_tail_pos[1], 2))
            mov_vector[1] = (snake_head_pos[1] - snake_tail_pos[1]) / math.sqrt(
                pow(snake_head_pos[0] - snake_tail_pos[0], 2) + pow(snake_head_pos[1] - snake_tail_pos[1], 2))
            # rotating...
            rotated_vector[0] = mov_vector[0]*dir_vector[0] - mov_vector[1]*dir_vector[1]
            rotated_vector[1] = mov_vector[1]*dir_vector[0] + mov_vector[0]*dir_vector[1]
            # the result vector for the NN!
            result_array[0] = rotated_vector[0] if rotated_vector[0] > 0 else 0
            result_array[1] = rotated_vector[1]  if rotated_vector[1] > 0 else 0
            result_array[2] = rotated_vector[0] if rotated_vector[0] < 0 else 0
	    result_array[3] = rotated_vector[1]  if rotated_vector[1] < 0 else 0
            # just writing result vector in file
            data.write("%s %s %s %s\n" % (result_array[0], result_array[1], result_array[2], result_array[3]))

       #print("the result array is (%f %f %f %f\n"%(result_array[0], result_array[1], result_array[2], result_array[3]))
    return


def callback_get_tail_coords(msg):
    global snake_tail_pos
    # just constantly (with ~200hz frequency) getting the tail coords
    if record_mode == 0:
        snake_tail_pos = [0.0, 0.0]
    if record_mode == 1:
        snake_tail_pos = [msg.pose[17].position.x, msg.pose[17].position.y]
    return


def listener():
    # In ROS, nodes are uniquely named. If two nodes with the same
    # node are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.

    rospy.init_node('get_pose', anonymous=True)
    publisher()
    # we need both rostopics because 'model_states' stores the head and 
    # target coordinates, while 'link_states' stores the coordinates of 
    # a tail module (as well as all the others intermediate modules)
    rospy.Subscriber("gazebo/model_states", ModelStates, callback_calc_vector)
    rospy.Subscriber("gazebo/link_states", LinkStates, callback_get_tail_coords)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

def publisher():
    # In ROS, nodes are uniquely named. If two nodes with the same
    # node are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.
    global pub
    global angle
    rate = rospy.Rate(20) # 20hz
    print("hi")
    while not rospy.is_shutdown():
        angle = "dummy angle"
        rospy.loginfo(angle)
        pub.publish(angle)
        rate.sleep()
